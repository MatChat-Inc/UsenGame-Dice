@tool
extends EditorPlugin

var res_dict = {}
var output_path = "res://R.gd"
var output_path_cs = "res://R.cs"
var editor_interface = null

var valid_extensions: Array[String] = ["tscn", "gd", "cs", "gdns", "tres", "res", "json", "xml", "txt", "shader", "material", "png", "jpg", "jpeg", "tga", "bmp", "hdr", "svg", "wav", "ogg", "mp3", "m4a", "opus", "wav", "obj", "mtl", "glb", "gltf", "fbx", "dae", "escn", "scn", "scon", "mesh", "material", "shader", "shader_material", "visual_shader", "script", "gd", "cs", "gdns", "tres", "res", "json", "xml", "txt", "shader", "material", "png", "jpg", "jpeg", "tga", "bmp", "hdr", "svg", "wav", "ogg", "mp3", "m4a", "opus", "wav", "obj", "mtl", "glb", "gltf", "fbx", "dae", "escn", "scn", "scon", "mesh", "material", "shader", "shader_material", "visual_shader", "script"]
var invalid_extensions: Array[String] = ["import", "uid", "bak", "backup", "temp", "tmp", "old"]

func _enter_tree():
	editor_interface = get_editor_interface()
	var icon = load("res://icon.svg")

	# Register the plugin's own script as the base script for custom type
	var script = load("res://addons/R.godot/R.godot.gd")
	if icon is Texture2D and script is Script:
		add_custom_type("R", "Node", script, icon)

	print("R.godot plugin enabled and initialized.")

	generate_resource_file()

	var editor_file_system = editor_interface.get_resource_filesystem()
	editor_file_system.connect("filesystem_changed", Callable(self, "_on_filesystem_changed"))

func _exit_tree():
	remove_custom_type("R")
	print("R.godot plugin disabled.") 

func _on_filesystem_changed():
	print("Filesystem changed, regenerating resource files...")
	generate_resource_file()

func generate_resource_file():
	res_dict = {}
	_scan_directory("res://")

	if ProjectSettings.has_setting("application/run/main_scene"):
		var main_scene = ProjectSettings.get_setting("application/run/main_scene")
		res_dict["MainScene"] = main_scene

	_generate_gdscript_file()

	if ProjectSettings.get_setting("mono/enabled", false):
		_generate_csharp_file()

func _scan_directory(path: String):
	if not _validate_path(path): return

	var dir = DirAccess.open(path)
	if dir:
		print("Scanning directory: ", path)
		dir.list_dir_begin()
		var file_name = dir.get_next()
		while file_name != "":
			if file_name != "." and file_name != "..":
				var file_path = path.path_join(file_name)
				if dir.current_is_dir():
					_scan_directory(file_path)
				else:
					_add_resource(file_path)
			file_name = dir.get_next()
		dir.list_dir_end()
	else:
		print("Failed to open directory: ", path)

func _add_resource(file_path: String):
	var extension = file_path.get_extension().to_lower()
	if !valid_extensions.has(extension): return

	var name = file_path.replace("res://", "").replace("/", "_").replace(".", "_")
	res_dict[name] = file_path

func _generate_gdscript_file():
	print("Generating GDScript file...")
	var file = FileAccess.open(output_path, FileAccess.WRITE)
	if file:
		file.store_line("# This file is auto-generated by R.godot")
#		file.store_line("class_name R")
		for key in res_dict.keys():
			var indentifier: String = process_name(key)
			file.store_line("static var %s: String:\n	get: return \"%s\"" % [indentifier, res_dict[key]])
		file.close()
		print("R.gd file successfully generated.")
	else:
		print("Failed to open R.gd for writing.")

func _generate_csharp_file():
	print("Generating C# file...")
	var file = FileAccess.open(output_path_cs, FileAccess.WRITE)
	if file:
		file.store_line("// This file is auto-generated by R.godot")
		file.store_line("public static class R")
		file.store_line("{")
		for key in res_dict.keys():
			var indentifier: String = process_name_cs(key)
			file.store_line("    public const string %s = \"%s\";" % [indentifier, res_dict[key]])
		file.store_line("}")
		file.close()
		print("R.cs file successfully generated.")
	else:
		print("Failed to open R.cs for writing.")


func process_name(old_name: String, use_pascal_case: bool = false) -> String:
	var name: String = old_name.to_lower()

	# Convert to PascalCase if USE_PASCALCASE is true
	if use_pascal_case:
		name = to_pascal_case(name)

	if name.length() > 0 and !name[0].is_valid_identifier():
		name = "_" + name

	# Create RegEx for removing non-word characters
	var regex = RegEx.new()
	regex.compile("[^\\w]") # Matches any character that's not a word character
	name = regex.sub(name, "_", true) # Replace all matches with underscore

	# If starts with a number, add an underscore
	if name.length() > 0 and name[0].is_valid_int():
		name = "_" + name

	# If starts with a number, add an underscore
	if name.length() > 0 and name[0].is_valid_int():
		name = "_" + name

	return name

func process_name_cs(old_name: String) -> String:
	var name = process_name(old_name, true)

	# If starts with a number, add an underscore
	if name.length() > 0 and name[0].is_valid_int():
		name = "_" + name

	return name

# Helper function to convert string to PascalCase
func to_pascal_case(text: String) -> String:
	var words = text.split("_")
	var result = ""

	for word in words:
		if word.length() > 0:
			result += word.substr(0, 1).to_upper() + word.substr(1).to_lower()

	return result

func _check_if_csharp_enabled() -> bool:
	var dir = DirAccess.open("res://")
	if dir:
		dir.list_dir_begin()  # Skip hidden files and directories
		while true:
			var file = dir.get_next()
			if file == "": break
			if file.ends_with(".csproj"):
				return true
	return false

func _validate_path(path: String) -> bool:
	var invalid_prefixes = ["res://addons", "res://."]
	for prefix in invalid_prefixes:
		if path.begins_with(prefix):
			return false
	return true
