@tool
extends EditorPlugin

# Reference to the editor's file system
var fs: EditorFileSystem

# Called when the plugin is enabled
func _enter_tree():
	fs = EditorInterface.get_resource_filesystem()
	if fs == null:
		print("Error: EditorFileSystem is null")
		return
	# Connect to the filesystem_changed signal to update the file on resource changes
	fs.filesystem_changed.connect(_on_filesystem_changed)
	# Generate the file initially
	_generate_r_file()

# Called when the plugin is disabled
func _exit_tree():
	if fs and fs.filesystem_changed.is_connected(_on_filesystem_changed):
		fs.filesystem_changed.disconnect(_on_filesystem_changed)

# Called when the file system changes (e.g., resource added or removed)
func _on_filesystem_changed():
	_generate_r_file()

# Main function to generate the R file
func _generate_r_file():
	if fs == null:
		print("Error: EditorFileSystem is null, cannot generate R file")
		return
	# Determine if C# is enabled
	var is_csharp = _check_if_csharp_enabled()
	var root_dir = fs.get_filesystem()  # Using your approach
	if root_dir == null:
		print("Error: Root directory is null")
		return

	# Generate the class structure based on language
	var code = _generate_csharp_code(root_dir, true) if is_csharp else _generate_gdscript_code(root_dir, true)

	# Add language-specific headers and footers
	if is_csharp:
		code = "// Autogenerated by R.godot addon. Do not edit manually.\nusing Godot;\n\n" + code + "\n}"
	else: code = "# Autogenerated by R.godot addon. Do not edit manually.\n" + code

	# Determine the output file path based on language
	var file_path = "res://R.cs" if is_csharp else "res://R.gd"

	# Read existing file content to avoid unnecessary writes
	var file = FileAccess.open(file_path, FileAccess.READ)
	var existing_code = ""
	if file:
		existing_code = file.get_as_text()
		file.close()

	# Write only if content has changed
	if code != existing_code:
		file = FileAccess.open(file_path, FileAccess.WRITE)
		if file:
			file.store_string(code)
			file.close()
			# Trigger a file system scan to ensure the editor recognizes the update
			#fs.scan()
		else:
			print("Error: Failed to write to file ", file_path)
		
	# Add to autoload if not already present
	if is_csharp:
		# check if R.gd exists in the project
		var autoload_setting = ProjectSettings.get("autoload/R")
		if autoload_setting != null and !FileAccess.file_exists("res://R.gd"):
			remove_autoload_singleton("R")
	else: add_autoload_singleton("R", "res://R.gd")
	


# Generate C# code for the class structure
func _generate_csharp_code(dir: EditorFileSystemDirectory, is_root: bool) -> String:
	var code = ""
	var classname = "R"
	var indent = "	" if is_root else ""

	# Handle root class or nested class
	if is_root:
		code += "public static class R\n{\n"
	else:
		classname = process_name_cs(dir.get_name())
		code += indent + "public class %s\n%s{\n" % [classname, indent]

	# Track used names to handle conflicts
	var used_names = {}

	# Process files in the current directory
	for i in dir.get_file_count():
		var file_name = dir.get_file(i)
		var path = dir.get_file_path(i)
		var type = dir.get_file_type(i)
		var var_name = process_name_cs(file_name.get_basename())
		
		# Resolve naming conflicts
		var original_var_name = var_name
		var count = 1
		while var_name in used_names:
			count += 1
			var_name = original_var_name + "_" + str(count)
		used_names[var_name] = true
		
		if var_name == classname: var_name += "_"

		# Map Godot resource types to C# types
		var cs_type = type
		if type == "Texture":
			cs_type = "Texture2D"  # Adjust for Godot 4 compatibility
		if type == "TextFile":
			continue # Skip text files
		if type == "JSON":
			continue # Skip text files
		if type.begins_with("AudioStream"):
			cs_type = "AudioStream"  # Adjust for Godot 4 compatibility
		if type.begins_with("Spine"):
			continue # Skip Spine resources
		
		
		# Add more type mappings as needed
		code += indent + "    public static %s %s => GD.Load<%s>(\"%s\");\n" % [cs_type, var_name, cs_type, path]

	# Process subdirectories
	for i in dir.get_subdir_count():
		var subdir = dir.get_subdir(i)
		var sub_code = _generate_csharp_code(subdir, false)
		code += sub_code.indent(indent + "	")

	# Close the class block
	if not is_root:
		code += indent + "}\n"

	return code

# Generate GDScript code for the class structure
func _generate_gdscript_code(dir: EditorFileSystemDirectory, is_root: bool) -> String:
	var code = ""
	var indent = ""

	# Handle root class or nested class
	if is_root:
		code += "extends Node\n\n"
	else:
		var name = process_name(dir.get_name())
		code += indent + "class %s:\n" % name
		if dir.get_file_count() == 0 and dir.get_subdir_count() == 0:
			code += indent + "	pass\n"
			return code  # Skip empty directories

	# Track used names to handle conflicts
	var used_names = {}

	# Process files in the current directory
	for i in dir.get_file_count():
		var file_name = dir.get_file(i)
		var path = dir.get_file_path(i)
		var var_name = process_name(file_name.get_basename())

		# Resolve naming conflicts
		var original_var_name = var_name
		var count = 1
		while var_name in used_names:
			count += 1
			var_name = original_var_name + "_" + str(count)
		used_names[var_name] = true
		
		if !is_root:
			code += indent + "	static var %s:\n		get: return load(\"%s\")\n" % [var_name, path]
		else: code += indent + "static var %s:\n	get: return load(\"%s\")\n" % [var_name, path]

	# Process subdirectories
	for i in dir.get_subdir_count():
		var subdir = dir.get_subdir(i)
		var sub_code = _generate_gdscript_code(subdir, false)
		if !is_root:
			code += sub_code.indent(indent + "	")
		else: code += sub_code.indent(indent)

	return code

# Sanitize a name to make it a valid identifier
func _sanitize_name(name: String) -> String:
	var sanitized = ""
	for c in name:
		if (c >= 'a' and c <= 'z') or (c >= 'A' and c <= 'Z') or c == "_":
			sanitized += c
		elif c >= '0' and c <= '9':
			if sanitized == "":
				sanitized += "_"  # Prepend underscore if name starts with a digit
			sanitized += c
		else:
			sanitized += "_"  # Replace invalid characters with underscore
	return sanitized if sanitized != "" else "_"  # Ensure non-empty name

func _check_if_csharp_enabled() -> bool:
	var dir = DirAccess.open("res://")
	if dir:
		dir.list_dir_begin()  # Skip hidden files and directories
		while true:
			var file = dir.get_next()
			if file == "": break
			if file.ends_with(".csproj"):
				return true
	return false

func process_name(old_name: String, use_pascal_case: bool = false) -> String:
	var name: String = old_name.to_lower()

	# Convert to PascalCase if USE_PASCALCASE is true
	if use_pascal_case:
		name = to_pascal_case(name)
	
	if name.length() > 0 and !name[0].is_valid_identifier():
		name = "_" + name

	# Create RegEx for removing non-word characters
	var regex = RegEx.new()
	regex.compile("[^\\w]") # Matches any character that's not a word character
	name = regex.sub(name, "_", true) # Replace all matches with underscore
	
	# If starts with a number, add an underscore
	if name.length() > 0 and name[0].is_valid_int():
		name = "_" + name
		
	# If starts with a number, add an underscore
	if name.length() > 0 and name[0].is_valid_int():
		name = "_" + name		

	return name

func process_name_cs(old_name: String) -> String:
	var name = process_name(old_name, true)
	return name

# Helper function to convert string to PascalCase
func to_pascal_case(text: String) -> String:
	var words = text.split("_")
	var result = ""

	for word in words:
		if word.length() > 0:
			result += word.substr(0, 1).to_upper() + word.substr(1).to_lower()

	return result
	